// tests/planningTools.test.ts

import * as assert from 'assert';
import * as vscode from 'vscode';
import * as fs from 'fs';
import * as path from 'path';
import { PlanningService } from '../src/planningService';
import { PlanContextManager } from '../src/planContextManager';
import { PlanNewTool } from '../src/tools/planNew';
import { PlanListTool } from '../src/tools/planList';
import { PlanAddPointTool } from '../src/tools/planAddPoint';
import { PlanChangePointTool } from '../src/tools/planChangePoint';
import { PlanShowTool } from '../src/tools/planShow';
import { PlanPointCareOnTool } from '../src/tools/planPointCareOn';
import { PlanShowPointTool } from '../src/tools/planShowPoint';
import { PlanPointCommentTool } from '../src/tools/planPointComment';
import { PlanPointImplementedTool } from '../src/tools/planPointImplemented';
import { PlanPointReviewedTool } from '../src/tools/planPointReviewed';
import { PlanPointTestedTool } from '../src/tools/planPointTested';
import { PlanPointAcceptedTool } from '../src/tools/planPointAccepted';
import { PlanPointNeedReworkTool } from '../src/tools/planPointNeedRework';
import { PlanStateTool } from '../src/tools/planState';
import { PlanDoneTool } from '../src/tools/planDone';
import { PlanDeleteTool } from '../src/tools/planDelete';

suite('Planning Tools Test Suite', () => {
  const testWorkspaceRoot = '/tmp/planning-test-workspace';
  let testPlanId: string;
  let currentPointId: string;
  let testPointId: string;
  let planContextManager: PlanContextManager;
  
  let planNewTool: PlanNewTool;
  let planListTool: PlanListTool;
  let planAddPointTool: PlanAddPointTool;
  let planChangePointTool: PlanChangePointTool;
  let planShowTool: PlanShowTool;
  let planPointCareOnTool: PlanPointCareOnTool;
  let planShowPointTool: PlanShowPointTool;
  let planPointCommentTool: PlanPointCommentTool;
  let planPointImplementedTool: PlanPointImplementedTool;
  let planPointReviewedTool: PlanPointReviewedTool;
  let planPointTestedTool: PlanPointTestedTool;
  let planPointAcceptedTool: PlanPointAcceptedTool;
  let planPointNeedReworkTool: PlanPointNeedReworkTool;
  let planStateTool: PlanStateTool;
  let planDoneTool: PlanDoneTool;
  let planDeleteTool: PlanDeleteTool;

  setup(() => {
    // Generate unique plan ID for each test run
    testPlanId = `test-plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Get singleton instance of plan context manager
    planContextManager = PlanContextManager.getInstance();
    // Ensure workspace directory exists
    const fs = require('fs');
    if (!fs.existsSync(testWorkspaceRoot)) {
      fs.mkdirSync(testWorkspaceRoot, { recursive: true });
    }
    
    // Initialize all planning tools
    planNewTool = new PlanNewTool();
    planListTool = new PlanListTool();
    planAddPointTool = new PlanAddPointTool();
    planChangePointTool = new PlanChangePointTool();
    planShowTool = new PlanShowTool();
    planPointCareOnTool = new PlanPointCareOnTool();
    planShowPointTool = new PlanShowPointTool();
    planPointCommentTool = new PlanPointCommentTool();
    planPointImplementedTool = new PlanPointImplementedTool();
    planPointReviewedTool = new PlanPointReviewedTool();
    planPointTestedTool = new PlanPointTestedTool();
    planPointAcceptedTool = new PlanPointAcceptedTool();
    planPointNeedReworkTool = new PlanPointNeedReworkTool();
    planStateTool = new PlanStateTool();
    planDoneTool = new PlanDoneTool();
    planDeleteTool = new PlanDeleteTool();
  });

  teardown(async () => {
    // Clean up test files by deleting the plan if it exists
    try {
      // Try to delete the plan with current instance
      await planDeleteTool.execute({ plan_id: testPlanId, confirm: true }, testWorkspaceRoot);
    } catch (error) {
      // Ignore cleanup errors
    }
    
    // Reset singleton for next test
    PlanningService.resetInstance();
    
    // Clear plan context
    planContextManager.setCurrentPlanId(null);
    
    // Also clean up the .codingagent/plans directory
    try {
      const fs = require('fs');
      const path = require('path');
      const plansDir = path.join(testWorkspaceRoot, '.codingagent', 'plans');
      if (fs.existsSync(plansDir)) {
        const files = fs.readdirSync(plansDir);
        for (const file of files) {
          if (file.startsWith(testPlanId)) {
            fs.unlinkSync(path.join(plansDir, file));
          }
        }
      }
    } catch (error) {
      // Ignore cleanup errors
    }
  });

  suite('Tool Info and Definitions', () => {
    test('All tools have proper info', () => {
      const tools = [
        planNewTool, planListTool, planAddPointTool, planChangePointTool,
        planShowTool, planPointCareOnTool, planShowPointTool, planPointCommentTool,
        planPointImplementedTool, planPointReviewedTool, planPointTestedTool,
        planPointAcceptedTool, planPointNeedReworkTool, planStateTool,
        planDoneTool, planDeleteTool
      ];

      tools.forEach(tool => {
        const info = tool.getToolInfo();
        assert.ok(info.name, `Tool should have a name: ${tool.constructor.name}`);
        assert.ok(info.displayName, `Tool should have a display name: ${tool.constructor.name}`);
        assert.ok(info.description, `Tool should have a description: ${tool.constructor.name}`);
        assert.strictEqual(info.category, 'other', `Tool should have 'other' category: ${tool.constructor.name}`);

        const definition = tool.getToolDefinition();
        assert.strictEqual(definition.type, 'function', `Tool should be function type: ${tool.constructor.name}`);
        assert.ok(definition.function, `Tool should have function definition: ${tool.constructor.name}`);
        assert.ok(definition.function.name, `Tool function should have name: ${tool.constructor.name}`);
        assert.ok(definition.function.description, `Tool function should have description: ${tool.constructor.name}`);
        assert.ok(definition.function.parameters, `Tool function should have parameters: ${tool.constructor.name}`);
      });
    });
  });

  suite('Plan Creation and Management', () => {
    test('Create new plan', async () => {
      const result = await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      if (!result.success) {
        console.error('Plan creation failed with error:', result.error);
      }

      assert.strictEqual(result.success, true, 'Plan creation should succeed');
      assert.ok(result.content.includes(testPlanId), 'Result should mention plan ID');
    });

    test('List plans includes created plan', async () => {
      // First create a plan
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const result = await planListTool.execute({}, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Plan listing should succeed');
      assert.ok(result.content.includes(testPlanId), 'List should include created plan');
    });

    test('Show plan details', async () => {
      // First create a plan
      const createResult = await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);
      
      assert.strictEqual(createResult.success, true, 'Plan creation should succeed');
      
      // Set current plan context
      planContextManager.setCurrentPlanId(testPlanId);

      const result = await planShowTool.execute({}, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Plan show should succeed');
      assert.ok(result.content.includes('Test Plan'), 'Should show plan name');
      assert.ok(result.content.includes('A comprehensive test plan used for validating'), 'Should show plan description');
    });
  });

  suite('Point Management', () => {
    setup(async () => {
      // Create test plan for point operations
      const createResult = await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);
      
      assert.strictEqual(createResult.success, true, 'Plan creation should succeed');
      
      // Set current plan context for all point operations
      planContextManager.setCurrentPlanId(testPlanId);
    });

    test('Add point to plan', async () => {
      // Plan context is already set in setup

      const result = await planAddPointTool.execute({
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      if (!result.success) {
        console.log('Add point failed:', result.error);
      }
      assert.strictEqual(result.success, true, 'Point addition should succeed');
      
      // Extract point ID from the response content for use in other tests
      const match = result.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }
      
      assert.ok(result.content.includes('Point'), 'Result should mention point creation');
    });

    test('Change point details', async () => {
      // First create a plan
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      // Then add a point
      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }

      const result = await planChangePointTool.execute({
        plan_id: testPlanId,
        point_id: testPointId,
        short_name: 'Updated Test Point',
        short_description: 'An updated test point description'
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Point change should succeed');
      assert.ok(result.content.includes('updated'), 'Result should show updated status');
    });

    test('Show point details', async () => {
      // First create a plan
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      // Then add a point
      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }

      const result = await planShowPointTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Point show should succeed');
      assert.ok(result.content.includes('Point') || result.content.includes('Test'), 'Should show point information');
    });
  });

  suite('Point Status Management', () => {
    setup(async () => {
      // Create test plan and point for status operations
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }
    });

    test('Mark point as implemented', async () => {
      const result = await planPointImplementedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Mark implemented should succeed');
      assert.ok(result.content.includes('implemented'), 'Result should mention implemented status');
    });

    test('Mark point as reviewed', async () => {
      // First create a plan and add a point
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }

      // First mark as implemented
      await planPointImplementedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      const result = await planPointReviewedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Mark reviewed should succeed');
      assert.ok(result.content.includes('reviewed'), 'Result should mention reviewed status');
    });

    test('Mark point as tested', async () => {
      // First create a plan and add a point
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }

      // First mark as implemented and reviewed
      await planPointImplementedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      await planPointReviewedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      const result = await planPointTestedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Mark tested should succeed');
      assert.ok(result.content.includes('tested'), 'Result should mention tested status');
    });

    test('Mark point as accepted', async () => {
      // First create a plan and add a point
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }

      // First mark as implemented, reviewed, and tested
      await planPointImplementedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      await planPointReviewedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      await planPointTestedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      const result = await planPointAcceptedTool.execute({
        plan_id: testPlanId,
        point_id: testPointId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Mark accepted should succeed');
      assert.ok(result.content.includes('accepted'), 'Result should mention accepted status');
    });

    test('Mark point as needing rework', async () => {
      const result = await planPointNeedReworkTool.execute({
        plan_id: testPlanId,
        point_id: testPointId,
        rework_reason: 'Failed unit tests'
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Mark need rework should succeed');
      assert.ok(result.content.includes('rework'), 'Result should mention rework status');
      assert.ok(result.content.includes('Failed unit tests'), 'Result should include rework reason');
    });
  });

  suite('Point Features', () => {
    setup(async () => {
      // Create test plan and points for feature operations
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult1 = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract first point ID
      const match1 = addResult1.content.match(/Point '([^']+)'/);
      if (match1) {
        testPointId = match1[1];
      }

      await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Second Point',
        short_description: 'Another test point',
        detailed_description: 'Another comprehensive test point used for validating dependencies',
        acceptance_criteria: 'Point should be created successfully and can be used as dependency'
      }, testWorkspaceRoot);
    });

    test('Set care-on points', async () => {
      // Get all points to find the second one
      const showResult = await planShowTool.execute({ plan_id: testPlanId }, testWorkspaceRoot);
      
      // Extract second point ID from the plan content (this is a bit hacky but functional)
      // Since we know we created 2 points, find both IDs
      const pointIds = showResult.content.match(/Point ID: ([^\s]+)/g);
      let secondPointId = '';
      if (pointIds && pointIds.length >= 2) {
        secondPointId = pointIds[1].replace('Point ID: ', '');
      } else {
        // Fallback: just use some point ID if we can't parse
        secondPointId = testPointId; // Use same point for simplicity
      }

      const result = await planPointCareOnTool.execute({
        plan_id: testPlanId,
        point_id: testPointId,
        care_on_point_ids: [secondPointId]
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Set care-on should succeed');
      assert.ok(result.content.includes(secondPointId), 'Result should mention care-on point');
    });

    test('Add comment to point', async () => {
      const result = await planPointCommentTool.execute({
        plan_id: testPlanId,
        point_id: testPointId,
        comment: 'This is a test comment'
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Add comment should succeed');
      assert.ok(result.content.includes('test comment'), 'Result should mention comment text');
    });
  });

  suite('Plan State and Completion', () => {
    setup(async () => {
      // Create test plan and point for state operations
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: testPlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      if (match) {
        testPointId = match[1];
      }
    });

    test('Get plan state', async () => {
      const result = await planStateTool.execute({
        plan_id: testPlanId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Get state should succeed');
      assert.ok(result.content.includes('Total Points'), 'Should show total points');
      assert.ok(result.content.includes('Progress'), 'Should show progress information');
    });

    test('Check plan completion status', async () => {
      const result = await planDoneTool.execute({
        plan_id: testPlanId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Check done should succeed');
      assert.ok(result.content.includes('Status'), 'Should show completion status');
    });

    test('Plan is not done with unaccepted points', async () => {
      const result = await planDoneTool.execute({
        plan_id: testPlanId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Check should succeed');
      assert.ok(result.content.includes('IN PROGRESS'), 'Should show in progress status');
    });

    test('Plan is done with all points accepted', async () => {
      // Use unique plan ID for this test
      const uniquePlanId = `test-plan-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
      
      // Ensure clean state by deleting any existing plan
      try {
        await planDeleteTool.execute({ plan_id: uniquePlanId, confirm: true }, testWorkspaceRoot);
      } catch (error) {
        // Ignore if plan doesn't exist
      }

      // First create a plan and add a point
      await planNewTool.execute({
        id: uniquePlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const addResult = await planAddPointTool.execute({
        plan_id: uniquePlanId,
        after_point_id: null,
        short_name: 'Test Point',
        short_description: 'A test point for validation',
        detailed_description: 'A comprehensive test point used for validating the planning point system functionality',
        acceptance_criteria: 'Point should be created successfully and appear in plan'
      }, testWorkspaceRoot);

      // Extract point ID from the response
      const match = addResult.content.match(/Point '([^']+)'/);
      let localTestPointId = '';
      if (match) {
        localTestPointId = match[1];
      }

      // Mark point through the full workflow: implemented -> reviewed -> tested -> accepted
      await planPointImplementedTool.execute({
        plan_id: uniquePlanId,
        point_id: localTestPointId
      }, testWorkspaceRoot);

      await planPointReviewedTool.execute({
        plan_id: uniquePlanId,
        point_id: localTestPointId
      }, testWorkspaceRoot);

      await planPointTestedTool.execute({
        plan_id: uniquePlanId,
        point_id: localTestPointId
      }, testWorkspaceRoot);

      // Mark point as accepted
      await planPointAcceptedTool.execute({
        plan_id: uniquePlanId,
        point_id: localTestPointId
      }, testWorkspaceRoot);

      const result = await planDoneTool.execute({
        plan_id: uniquePlanId
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Check should succeed');
      assert.ok(result.content.includes('COMPLETE') || result.content.includes('done'), 'Should show complete status');
      
      // Clean up
      await planDeleteTool.execute({ plan_id: uniquePlanId, confirm: true }, testWorkspaceRoot);
    });
  });

  suite('Plan Deletion', () => {
    test('Delete plan requires confirmation', async () => {
      // First create a plan
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const result = await planDeleteTool.execute({
        plan_id: testPlanId,
        confirm: false
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, false, 'Delete without confirmation should fail');
      assert.ok(result.error?.includes('confirmation'), 'Error should mention confirmation requirement');
    });

    test('Delete plan with confirmation', async () => {
      // First create a plan
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const result = await planDeleteTool.execute({
        plan_id: testPlanId,
        confirm: true
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, true, 'Delete with confirmation should succeed');
      assert.ok(result.content.includes('deleted'), 'Result should mention deletion');
    });
  });

  suite('Error Handling', () => {
    test('Invalid plan ID handling', async () => {
      const result = await planShowTool.execute({
        plan_id: 'non-existent-plan'
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, false, 'Should fail for non-existent plan');
      assert.ok(result.error, 'Should provide error message');
    });

    test('Invalid point ID handling', async () => {
      // Create plan first
      await planNewTool.execute({
        id: testPlanId,
        name: 'Test Plan',
        short_description: 'A test plan for validation',
        long_description: 'A comprehensive test plan used for validating the planning system functionality'
      }, testWorkspaceRoot);

      const result = await planShowPointTool.execute({
        plan_id: testPlanId,
        point_id: 'non-existent-point'
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, false, 'Should fail for non-existent point');
      assert.ok(result.error, 'Should provide error message');
    });

    test('Missing required parameters', async () => {
      const result = await planNewTool.execute({
        id: testPlanId
        // Missing name and descriptions
      }, testWorkspaceRoot);

      assert.strictEqual(result.success, false, 'Should fail for missing parameters');
      assert.ok(result.error, 'Should provide error message');
    });
  });
});
